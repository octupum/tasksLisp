1. Запишите последовательности вызовов CAR и CDR, выделяющие из приведенных ниже списков символ цель. Упростите эти вывовы с помощью комбинации
селекторов:
• (1 2 цель 3 4)
• ((1) (2 цель) (3 (4)))
• ((1 (2 (3 4 цель))))
1.	(cadr '(1 2 цель 3 4))
2.	(caadr '((1) (2 цель) (3 (4))))
3.	(caddddr '((1 (2 (3 4 цель)))))

2. Определите функцию, возвращающую последний элемент списка.
(defun last-element (lst)
  (cond
    ((null lst) nil)  ; если список пуст, возвращаем nil
    ((null (cdr lst)) (car lst))  ; если в списке только один элемент, возвращаем этот элемент
    (t (last-element (cdr lst)))))  ; иначе рекурсивно вызываем функцию для хвоста списка
3. Определите функцию, заменяющую в исходном списке все вхождения заданного значения другим.
(defun replace-in-list (old new lst)
  (cond
    ((null lst) nil)  ; если список пуст, возвращаем пустой список
    ((equal (car lst) old)
     (cons new (replace-in-list old new (cdr lst))))  ; если первый элемент равен old, заменяем его на new и продолжаем обработку хвоста списка
    (t
     (cons (car lst) (replace-in-list old new (cdr lst))))))  ; если первый элемент не равен old, оставляем его как есть и продолжаем обработку хвоста списка
4. Определите функцию, порождающую по заданному натуральному числу N список, состоящий из натуральных чисел от 1 до N.
(defun generate-list (n)
  (labels ((gen-helper (current max)
             (if (> current max)
                 nil
                 (cons current (gen-helper (+ current 1) max)))))
    (gen-helper 1 n)))
5. Определите функцию, которая увеличивает элементы исходного списка на единицу.
(defun increment-elements (lst)
  (cond
    ((null lst) nil)  ; если список пуст, возвращаем пустой список
    (t
     (cons (+ 1 (car lst)) (increment-elements (cdr lst))))))  ; увеличиваем первый элемент на 1 и рекурсивно вызываем функцию для хвоста списка
6. Определите функцию, переводящую список чисел в список соответствующих им названий.

7. Определите функцию, удаляющую из исходного списка элементы с четными номерами.
(defun remove-even-indices (lst)
  (labels ((remove-helper (lst pos)
             (cond
               ((null lst) nil)  ; если список пуст, возвращаем пустой список
               ((evenp pos) (remove-helper (cdr lst) (+ pos 1)))  ; если позиция четная, пропускаем элемент и рекурсивно вызываем для хвоста списка с увеличенной позицией
               (t (cons (car lst) (remove-helper (cdr lst) (+ pos 1)))))))  ; если позиция нечетная, добавляем элемент в новый список и рекурсивно вызываем для хвоста списка с увеличенной позицией
    (remove-helper lst 1)))  ; начальный вызов вспомогательной функции с позицией 1
8. Определите функцию, которая разделит исходный список из целых чисел на два списка: список положительных чисел и список отрицательных чисел.
(defun split-list (lst)
  (labels ((split-helper (lst pos-list neg-list)
             (cond
               ((null lst) (values pos-list neg-list))  ; если список пуст, возвращаем два списка
               ((> (car lst) 0) (split-helper (cdr lst) (cons (car lst) pos-list) neg-list))  ; если текущий элемент положительный, добавляем его в pos-list
               ((< (car lst) 0) (split-helper (cdr lst) pos-list (cons (car lst) neg-list)))  ; если текущий элемент отрицательный, добавляем его в neg-list
               (t (split-helper (cdr lst) pos-list neg-list)))))  ; если текущий элемент ноль, просто пропускаем его
    (split-helper lst '() '())))  ; начальный вызов вспомогательной функции с пустыми списками для положительных и отрицательных чисел
9. Определите функцию, разделяющую исходный список на два подсписка. В первый из них должны попасть элементы с нечетными номерами, во второй - элементы с четными номерами.
(defun split-list (lst)
  (labels ((split-helper (lst odd-list even-list)
             (cond
               ((null lst) (values (reverse odd-list) (reverse even-list))) ; если список пуст, возвращаем два подсписка, но сначала разворачиваем их, чтобы восстановить порядок элементов
               ((null (cdr lst)) (split-helper (cdr lst) (cons (car lst) odd-list) even-list)) ; если остался только один элемент, добавляем его в список нечетных и заканчиваем
               (t (split-helper (cddr lst)  ; рекурсивно обрабатываем хвост списка, начиная с третьего элемента
                                (cons (car lst) odd-list)  ; добавляем первый элемент в список нечетных
                                (cons (cadr lst) even-list)))))) ; добавляем второй элемент в список четных
    (split-helper lst '() '()))) ; начальный вызов вспомогательной функции с пустыми подсписками
10. Определите функцию, осуществляющую удаление указанного количества последних элементов исходного списка.
(defun remove-last (lst n)
  (if (<= n 0)            ; Если количество элементов для удаления <= 0
      lst                 ; Возвращаем исходный список
      (if (null lst)      ; Если список пустой
          nil             ; Возвращаем пустой список
          (remove-last (butlast lst) (- n 1)))))  ; Рекурсивный вызов без последнего элемента и уменьшение счетчика
11. Определите функцию, осуществляющую разделение исходного списка на два подсписка. В первый из них должно попасть указанное количество элементов с начала списка, во второй - оставшиеся элементы.
(defun split-list (lst n)
  (if (<= n 0)              ; Если количество элементов для разделения <= 0
      (values '() lst)      ; Возвращаем пустой список и исходный список
      (if (null lst)        ; Если список пустой
          (values '() '())  ; Возвращаем два пустых списка
          (multiple-value-bind (first second)  ; Присваиваем значения двух переменных
              (split-list (cdr lst) (- n 1))   ; Рекурсивный вызов без первого элемента и уменьшение счетчика
            (values (cons (car lst) first) second)))))  ; Возвращаем пару подсписков (первый элемент + первый подсписок, второй подсписок)
12. Определите функцию, заменяющую в исходном списке два подряд идущих одинаковых элемента одним.
(defun replace-duplicates (lst)
  (cond
    ((or (null lst) (null (cdr lst))) lst) ; Если список пустой или содержит только один элемент, возвращаем его
    ((equal (car lst) (cadr lst))          ; Если первые два элемента равны
     (replace-duplicates (cddr lst)))      ; Пропускаем первый элемент и рекурсивно вызываем функцию для хвоста списка
    (t                                     ; Если первые два элемента не равны
     (cons (car lst) (replace-duplicates (cdr lst))))))  ; Добавляем первый элемент в новый список и рекурсивно вызываем функцию для хвоста списка
13. Определите функцию, удаляющую в исходном списке все повторные вхождения элементов.
(defun remove-duplicates (lst)
  (labels ((remove-dup-helper (lst seen)
             (cond
               ((null lst) nil) ; если список пуст, возвращаем пустой список
               ((member (car lst) seen) (remove-dup-helper (cdr lst) seen)) ; если первый элемент уже встречался, пропускаем его и продолжаем обработку хвоста списка
               (t (cons (car lst) (remove-dup-helper (cdr lst) (cons (car lst) seen))))))) ; если первый элемент не встречался, добавляем его в новый список и помечаем как встреченный
    (remove-dup-helper lst '()))) ; начальный вызов вспомогательной функции с пустым списком встреченных элементов
14. Определите функцию, осуществляющую перестановку двух элементов списка с заданными номерами.
(defun swap-elements (lst idx1 idx2)
  (cond
    ((or (>= idx1 (length lst)) (>= idx2 (length lst)) (< idx1 0) (< idx2 0) (= idx1 idx2)) lst) ; Проверяем корректность индексов
    ((= idx1 0) (replace-element (replace-element lst idx1 (nth idx2 lst)) idx2 (nth idx1 lst))) ; Меняем местами элементы, если первый индекс равен 0
    (t (cons (car lst) (swap-elements (cdr lst) (- idx1 1) (- idx2 1)))))) ; Рекурсивно вызываем функцию для хвоста списка, уменьшая оба индекса на 1

(defun replace-element (lst idx new)
  (if (zerop idx) ; Если индекс равен 0
      (cons new (cdr lst)) ; Заменяем первый элемент на новый
      (cons (car lst) (replace-element (cdr lst) (1- idx) new)))) ; Рекурсивно вызываем функцию для хвоста списка, уменьшая индекс на 1
15. Определите функцию, вычисляющую скалярное произведение векторов, заданных списками целых чисел.
(defun scalar-product (vec1 vec2)
  (if (or (null vec1) (null vec2))  ; Если один из векторов пуст
      0
      (+ (* (car vec1) (car vec2))  ; Произведение первых элементов
         (scalar-product (cdr vec1) (cdr vec2)))))  ; Рекурсивный вызов для хвостов векторов
16. Определите функцию, добавляющую элементы одного списка во второй список, начиная с заданной позиции.
(defun insert-at-position (list1 list2 position)
  (cond
    ((or (null list1) (zerop position)) list2)  ; Если list1 пуст или position равна 0, возвращаем list2
    (t (cons (car list1) (insert-at-position (cdr list1) list2 (1- position))))))  ; Рекурсивно добавляем элементы из list1 в list2, уменьшая position на 1
17. Создайте предикат, порождающий всевозможные перестановки исходного множества
18. Определите предикат, проверяющий, является ли аргумент одноуровневым
списком.
(defun flat-list-p (list)
  (every #'atom list))
19. Определите функцию (ЛУКОВИЦА n), строящую N-уровневый вложенный список, элементом которого на самом глубоком уровне является N.
(defun LUKOVICA (n)
  (if (= n 1)        ; Базовый случай: если n равно 1, возвращаем список, содержащий число 1
      (list n)
      (list (LUKOVICA (1- n)))))
20. Определите функцию ПЕРВЫЙ-АТОМ, результатом которой будет первый атом списка. Пример:
> (ПЕРВЫЙ-АТОМ ’(((a b)) c d))
A
(defun frst-atm (lst)
  (cond
    ((null lst) nil)  ; Если список пуст, возвращаем nil
    ((atom (car lst)) (car lst))  ; Если первый элемент - атом, возвращаем его
    (t (frst-atm (cdr lst)))))  ; Иначе рекурсивно вызываем функцию для хвоста списка
21. Определите функцию, удаляющую из списка первое вхождение данного элемента на верхнем уровне.
(defun remove-first-occurrence (item lst)
  (cond
    ((null lst) nil)  ; Если список пустой, возвращаем пустой список
    ((equal item (car lst)) (cdr lst))  ; Если первый элемент равен заданному значению, возвращаем хвост списка
    (t (cons (car lst) (remove-first-occurrence item (cdr lst))))))  ; Включаем первый элемент и рекурсивно вызываем функцию для хвоста списка
22. Определите функцию, которая обращает список (а b с) и разбивает его на
уровни (((с) b) а).
(defun reverse-nested (lst)
  (if (null lst)
      nil  ; Базовый случай: если список пуст, возвращаем пустой список
      (list (reverse-nested (cdr lst)) (car lst))))  ; Рекурсивно обращаем хвост списка и добавляем текущий элемент
23. Определите функции, преобразующие список (a b с) к виду (а (b (с))) и
наоборот.
(defun to-nested (lst)
  (if (null lst)
      nil  ; Базовый случай: если список пуст, возвращаем nil
      (if (null (cdr lst))
          (car lst)  ; Если список состоит из одного элемента, возвращаем его
          (list (car lst) (to-nested (cdr lst))))))  ; Иначе создаем вложенный список
24. Определите функции, осущеставляющие преобразования между видами (a b c)
и (((а) b) с).
(defun to-deeply-nested (lst)
  (if (null lst)
      nil  ; Базовый случай: если список пуст, возвращаем nil
      (if (null (cdr lst))
          (car lst)  ; Если список состоит из одного элемента, возвращаем его
          (list (to-deeply-nested (butlast lst)) (car (last lst))))))  ; Иначе создаем вложенный список
25. Определите функцию, удаляющую из списка каждый четный элемент.
(defun remove-even-elements (lst)
  (cond
    ((null lst) nil)  ; Если список пустой, возвращаем пустой список
    ((null (cdr lst)) lst)  ; Если в списке один элемент, возвращаем этот элемент
    (t (cons (car lst) (remove-even-elements (cddr lst))))))  ; Берем первый элемент и рекурсивно вызываем функцию для хвоста, пропуская один элемент
26. Определите функцию, разбивающую список (a b с d...) на пары ((а b) (с
d)...).
(defun pair-up (lst)
  (if (or (null lst) (null (cdr lst)))
      nil  ; Если список пустой или содержит менее двух элементов, возвращаем nil
      (cons (list (car lst) (cadr lst)) (pair-up (cddr lst)))))  ; Создаем пару и рекурсивно вызываем функцию для хвоста списка
27. Определите функцию, которая, чередуя элементы списков (a b...) и (1 2...),
образует новый список (a 1 b 2 ...).
(defun interleave (lst1 lst2)
  (cond
    ((null lst1) lst2)  ; Если первый список пустой, возвращаем второй список
    ((null lst2) lst1)  ; Если второй список пустой, возвращаем первый список
    (t (cons (car lst1) (cons (car lst2) (interleave (cdr lst1) (cdr lst2)))))))  ; Чередуем элементы и рекурсивно вызываем функцию для хвостов списков
28. Определите функцию, вычисляющую, сколько всего атомов в списке (списочной структуре).
(defun count-atoms (lst)
  (cond
    ((null lst) 0)  ; Если список пустой, возвращаем 0
    ((atom (car lst)) (+ 1 (count-atoms (cdr lst))))  ; Если первый элемент - атом, увеличиваем счетчик на 1 и рекурсивно вызываем функцию для хвоста списка
    (t (+ (count-atoms (car lst)) (count-atoms (cdr lst))))))  ; Иначе рекурсивно считаем атомы в первом элементе (который сам список) и хвосте списка
29. Определите функцию, вычисляющую глубину списка (самой глубокой ветви).
(defun max-depth (lst)
  (if (atom lst)
      0  ; Если элемент - атом, глубина 0
      (+ 1 (reduce 'max (mapcar 'max-depth lst)))))  ; Иначе вычисляем глубину для каждого элемента списка и берем максимальную
30. Запрограммируйте интерпретатор ВЫЧИСЛИ, который преобразует инфиксную
запись операций в префиксную и возвращает значение выражения. Пример:
> (ВЫЧИСЛИ ’((-2 + 4) * 3))
6
(defun calcul (expr)
  (cond
    ((atom expr) expr)  ; Если выражение - атом, возвращаем его
    (t (eval (list (intern (string (cadr expr)))  ; Преобразуем оператор в символ LISP
                  (calcul (car expr))  ; Рекурсивно вычисляем левое подвыражение
                  (calcul (caddr expr)))))))  ; Рекурсивно вычисляем правое подвыражение
31. Определите функцию (ПЕРВЫЙ-СОВПАДАюЩИЙ х у), которая возвращает первый
элемент, входящий в оба списка х и у, в противном случае NIL.
(defun perv-sovpad (x y)
  (cond
    ((null x) nil)  ; Если первый список пуст, возвращаем nil
    ((member (car x) y) (car x))  ; Если первый элемент списка x входит в y, возвращаем его
    (t (perv-sovpad (cdr x) y))))  ; Иначе рекурсивно вызываем функцию для хвоста x
32. Определите предикат МНОжЕСТВО-Р, который проверяет, является ли список
множеством, т.е. входит ли каждый элемент в список лишь один раз.
(defun mnozhestvo-p (lst)
  (cond
    ((null lst) t)  ; Если список пуст, возвращаем t
    ((member (car lst) (cdr lst)) nil)  ; Если первый элемент повторяется, возвращаем nil
    (t (mnozhestvo-p (cdr lst)))))  ; Иначе рекурсивно вызываем функцию для хвоста списка
33. Определите функцию МНОжЕСТВО, преобразующую список в множество.
(defun mnozhestvo (lst)
  (cond
    ((null lst) nil)
    ((member (car lst) (cdr lst)) (mnozhestvo (cdr lst)))  ; Если первый элемент повторяется, пропускаем его
    (t (cons (car lst) (mnozhestvo (cdr lst))))))  ; Иначе добавляем его в множество
34. Определите предикат РАВЕНСТВО-МНОжЕСТВ, проверяющий совпадение двух множ(неависимо от порядка следования элементов). Подсказка: напишите
функцию УДАЛИТь, удаляющую данный элемент из множества.
(defun delete (el lst)
  (cond
    ((null lst) nil)
    ((eql el (car lst)) (cdr lst))
    (t (cons (car lst) (delete el (cdr lst))))))

(defun equ-mnozhestv (set1 set2)
  (and (null (set-difference set1 set2)) (null (set-difference set2 set1))))
35. Определите функцию ПОДМНОжЕСТВО, которая проверяет, является ли одно множество подмножеством другого. Определите такое СОБСТВЕННОЕ-ПОДМНОжЕСТВО.
(defun podmnozhestvo (set1 set2)
  (cond
    ((null set1) t)
    ((member (car set1) set2) (podmnozhestvo (cdr set1) set2))
    (t nil)))
(defun self-podmnozhestvo (set1 set2)
  (and (podmnozhestvo set1 set2) (not (equ-mnozhestv set1 set2))))
36. Определите предикат НЕПЕРЕСЕКАюЩИЕСя, проверяющий, что два множества не
пересекаются, т.е. у них нет общих элементов.
(defun ne-peresechenie (set1 set2)
  (null (intersection set1 set2)))
37. Определите функцию ПЕРЕСЕЧЕНИЕ, формирующую пересечение двух множеств,
т.е. множество из их общих элементов.
(defun PERESECHENIE (set1 set2)
  (cond
    ((null set1) nil)
    ((member (car set1) set2) (cons (car set1) (PERESECHENIE (cdr set1) set2)))
    (t (PERESECHENIE (cdr set1) set2))))
38. Определите функцию ОБъЕДИНЕНИЕ, формирующую объединение двух множеств.
(defun OBEDENENIE (set1 set2)
  (cond
    ((null set1) set2)
    ((member (car set1) set2) (OBEDENENIE (cdr set1) set2))
    (t (cons (car set1) (OBEDENENIE (cdr set1) set2)))))
39. Определите функцию СИММЕТРИЧЕСКАя-РАзНОСТь, формирующую множество из
элементов не входящих в оба множества.
(defun symmetric-raznost (set1 set2)
  (union (set-difference set1 set2) (set-difference set2 set1)))
40. Определите функцию РАзНОСТь, формирующую разность двух множеств, т.е.
удаляющую из первого множества все общие со вторым множеством элементы.
(defun raznost (set1 set2)
  (cond
    ((null set1) nil)
    ((member (car set1) set2) (raznost (cdr set1) set2))
    (t (cons (car set1) (raznost (cdr set1) set2)))))
41. Реализовать генератор деревьев, чтобы выдаваемые им деревья имели количество вершин, точно соответствующее числу, указанному в его первом аргументе.
(defun generate-tree (n)
  (cond
    ((<= n 0) nil)
    (t (list n (generate-tree (/ n 2)) (generate-tree (/ n 2))))))

